from .operand import Operand
from typing import Optional

class Instruction:
    original: str
    vaddr: int
    length: int
    fname: str
    prefixes: list[str]
    mnemonic: str
    sign_ext: Optional[bool]
    size1: Optional[int]
    size2: Optional[int]
    cond: Optional[bool]
    c_neg: Optional[bool]
    c_eq: Optional[bool]
    c_left: Optional[bool]
    c_noflag: Optional[bool]
    flag_bit: Optional[bool]
    test_bit: Optional[bool]
    out: str
    ignored: bool
    _var_count: int
    _parsed_result_message: str
    instrumentation: bool

    def __init__(self, original: str, vaddr: str, encoded: str, prefix: str, mnemonic: str, operands: str, var_count: int, fxn: str) -> None: ...

    def __str__(self) -> str: ...

    def emit_get_flag(self, flags_mask: int, var: str) -> None: ...

    def emit_set_flag(self, flags_mask: int, value: str, clean_clobber_flags: bool) -> None: ...

    def _parse_op(self) -> None: ...

    def _parse_shift(self, suffix: str) -> str: ...

    def _parse_bt(self, suffix: str) -> str: ...

    def _parse_flag(self, suffix: str) -> str: ...

    def _parse_cond(self, suffix: str) -> str: ...

    def _parse_size(self, suffix: str) -> str: ...

    def _parse_mnemonic(self, suffix: str) -> str: ...

    def _parse_operands(self, operand_str: str) -> None: ...

    def _fixup_instructions(self) -> None: ...

    def emit_tase_springboard(self, suffix: str) -> None: ...

    def emit_function(self, Type: int) -> None: ...

    def _emit_function_prolog(self, suffix: str) -> None: ...

    def _make_var(self, prefix: str) -> str: ...

    def emit_var_decl(self, prefix: str, size: int, exp: str, signed: bool) -> str: ...

    def _emit_flag_decl(self) -> str: ...

    def _emit_xchg(self) -> None: ...

    def _emit_xadd(self) -> None: ...

    def _emit_zps(self, v_efl: str, v_res: str) -> None: ...

    def _emit_store_cozps(self, v_efl: str, clean_clobber_flags: bool) -> None: ...

    def _emit_add(self, arg_l: Optional[Operand], arg_r: Optional[Operand], carry: bool, sub: bool, target_l: bool, set_carry: bool, clean_clobber_flags: bool) -> None: ...

    def _emit_mul(self) -> None: ...

    def _emit_div(self) -> None: ...

    def _emit_logical(self, operator: str, write_target: bool, clean_clobber_flags: bool) -> None: ...

    def _emit_not(self) -> None: ...

    def _emit_set(self) -> None: ...

    def _emit_bittest(self) -> None: ...

    def _emit_flag(self, clear: bool) -> None: ...

    def _emit_cmc(self) -> None: ...

    def _emit_shift(self) -> None: ...

    def _emit_return_for_cond(self) -> str: ...

    def _emit_call(self) -> None: ...

    def _emit_ret(self) -> None: ...

    def _emit_loop(self) -> None: ...

    def _emit_mov(self, src: Optional[Operand], dest: Optional[Operand], size1: Optional[int], size2: Optional[int]) -> None: ...

    def _emit_lea(self, src: Optional[Operand], dest: Optional[Operand], size: Optional[int]) -> None: ...

    def _emit_ctd(self) -> None: ...

    def _emit_bswap(self) -> None: ...

    def _emit_cmov(self) -> None: ...

    def _emit_push(self, src: Optional[Operand], size: Optional[int]) -> None: ...

    def _emit_pop(self, dest: Optional[Operand], size: Optional[int]) -> None: ...

    def _emit_enter(self) -> None: ...

    def _emit_leave(self) -> None: ...

    def _emit_bsf(self) -> None: ...

    def _emit_bsr(self) -> None: ...
